\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{url}
\usepackage{listings}

\begin{document}

\def\File#1{\textsf{#1}}
\def\Code#1{\texttt{#1}}
\def\Key#1{\textsf{#1}}

\title{02220 Distributed systems}
\author{Kim Rostgaard Christensen (s084283)}

\maketitle

\tableofcontents

\begin{abstract}
This report describes the work done on implementing a distributed temperature monitoring network, for the course 02220 - Distributed systems using Java RMI, and various published distributed algorithms.
\end{abstract}

\section{Introduction}
The system implemented consists of a set of inter-connected nodes that each poll a local temperature sensor at a fixed frequency. One dedicated node is appointed the role of being the master-node, or more formally the admin node. Each node (including the regular node) reports it's local sensor values back to the admin node, which then stores them.
The admin node can suffer from temporary, or permanent failures, and therefore it must be possible to promote another node to admin. This is done via a user interface.

%\section{Terminology}
%\subsection{Semantics}
%\subsubsection{Maybe}
%\subsubsection{At-least-once}
%\subsubsection{At-most-once}

\section{The system}

The overall system model of a given number of nodes. For this model we assume at least four nodes including the admin.

\subsection{Network topology}
Given the project description, a fitting topology would be the suggested fully-connected, divided into a fully connected network for doing reliable multicast, and a star-topology network for sending the temperature measurements to the admin node - which of course is the center of the star.

Upon system startup every node is given a unique identification that must be quantifiable - i.e. it must be comparable. For simplicity, a simple incrementing numbering scheme is chosen, starting from 0. The number of nodes is given in \File(Configuration.java) file, and is thus known before run-time.

\begin{figure}[h]
\centering
\includegraphics[scale=0.65]{fig/Networkmodel.png}
 \caption{Network model}
 \label{fig:network_model}
\end{figure}


\section{Protocol design}
%synchronization primitives with multicast.
\subsection{Vector clocks}
Every node maintains a local vector clock that increments whenever the node changes state. This means whenever a new measurement is added, or whenever the node sends a message.
%Messages piggypacking VectorClock
%Number of nodes is specified in  file.

\section{Average temperature}

\section{Assumptions}
A RMI interface for looking up the current list of active nodes is provide for easy availability of information. In production this would introduce a single point of failure, and make the system too vulnerable to failures.


Alternative approaches would be to have every node maintain a list of active nodes

\begin{description}
 \item[A1] The system Contains no malicious nodes
 \item[A2] Every node has an accurate timer (not clock), so every node has the same notion of time passed, but not of absolute time
 \item[A3] A node does not change its period-count.
\end{description} 



Processes cannot affect each other by other means than IPC. Processes can therefore not make other process stop/start/restart, or similar.

\subsection{Network model}
The simulator contains an emulated network model to make monitoring easier. Every Node, including the admin, uses only RMI for communication primitives in order to enable nodes to run on different machines.
One possible exception could be the multicast primitives, that require a more technology-specific solution as RMI does not support multicast.

Every RMI call interface is explicitly specified. This gives us a safety that \emph{only} explicitly outlined calls are used througout the system. e.g. it would be a logical contradiction to multicast a temperature message, as these always have a destination. This, however gives some extra code overhead.

\subsection{Choice of RMI}
RMI is used as a means to abstract away the socket-fiddling, and to ensure at-most-once semantics. In practice, the implementation introduces a single point of failure in having to have a central registry for all services. A remedial action for this could be to distribute the registry to several servers.
% Why not CORBA / RMI-IIOP?

\subsection{Replication}
%The UnicastRemoteServer class defines a non-replicated remote object whose references are valid only while the server process is alive. 
As the Java interface \Code{UnicastRemoteServer} only support remote references, we will need to use serialization to ensure replication and pass-by-value of objects.

\subsection{Node realization}
Every node starts their life idle, and needs to be started manually using the \Code{Start()} call. For development and demonstration purposes, a bootstrapper has been developed to take care of the process launching. The bootstrapper also maintains the RMI registry, which otherwise would have to be run as separate command (\File{rmiregistry}).
Once the nodes have been started, they will register themselves as processes with their ID in the RMI registry.

\subsection{Assumptions and extensions}
As the system utilizes RMI\footnote{RMI uses at-most-once semantics}, we assume that any direct messages are sent reliably. Multicast messages, however, are sent unreliably and must thus be handled on the application layer.\\

% Ring topology; cleanup.
%The system is extended with new role for the nodes; router. The motivation is found in section \ref{network_topology}.
%It would be possible to extend the ring network by adding additional subnets and additional nodes to the local rings.
%Given the topology, we require an additional node role.\ref

\subsection{The transmitter}
The Transmitter as one purpose, gather messages in a circular queue and dispatch them in order. It was meant to also be able to handle re-ordering of packages to comply with either FIFO, Causal or total ordering. This feature was dropped due to increasing complexity, and lack of resources.

\subsection{Synchronous operations}

A single unique node is, by agreement among all nodes, elected as admin node. The election causes a global lock of all nodes until agreement is made.
\subsection{Nodes}
A node can be of three classes; Basic, Router and Admin. The constraints are as follows;
\begin{itemize}
\item A basic node is a system-wide root class of all nodes. All other classes inherit the functionality of this type of node.
\item The admin node is \emph{unique}, meaning that there can be only either 0 or 1 admin node at all times.
\item A router is a basic node that bridges ring networks. It is, similar to the admin node, unique - but only its local ring.
\end{itemize}


\subsection{Promoting a new admin}
Initially, this problem was treated as an election, then as a R-Multicast problem. But as development progressed it became apparent that it could be solved by the same means Byzantine generals solution, providing resilience to faulty nodes.
\begin{itemize}
\item The node proposed for the new admin node is the commander.
\item Every other node are the lieutenants.
\item 
\end{itemize}

The election starts by having the commander start  %TODO Reliable?
to every lieutenant.

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{fig/UI.png}
 \caption{User interface}
 \label{fig:ui}
\end{figure}


%The election can happen by first multicasting a startelection which will make every node go into a critical section.

\section{Security}
No security measures are taken in this system. The assumption is, that it is as closed loop system with no malicious nodes or individuals.

The security \emph{could} be improved by 
\begin{enumerate}
\item Adding a security manager to RMI
\item Supplying every node with a pre-shared key
\item Periodically cycle the encryption with a random key\footnote{From for example /dev/random on Linux/Unix systems}
\end{enumerate}
Securing the individual nodes on the opearating system level from leaking the pre-shared-key is out of scope of this report.

\subsection{Simulator design}
%Network model (monitor+graph+ui) - make drawing.

\subsection{Admin node shifting}
Under the assumption that 

\section{Conclusion}
Working with RMI has been a learning experience, but a positive one at that. It is extremely convenient to do distributed programming without having to deal with the many pitfalls of sockets, selectors, streams and file descriptors. Being able to design the protocol pseudo-formally in the Java language takes a lot of the load of having to solve general problems regarding transfers, generally.
On a personal note; It is this authors opinion that a hands-on approach to algorithms is the best way to understand them. Hence, experiencing the application of them, when faced with real problems.
A lot of time was spent trying to implement the Byzantine Generals solution algorithm.

\end{document}
%TODO References.
%@article{lamport1982byzantine,
%  title={The Byzantine generals problem},
%  author={Lamport, Leslie and Shostak, Robert and Pease, Marshall},
% journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
%  volume={4},
%  number={3},
%  pages={382--401},
%  year={1982},
%  publisher={ACM}
%}